

进程、线程、Go协程

## 进程与线程

go中的协程与操作系统中的线程、进程有紧密的联系。

进程：程序运行的实例，可以有多个线程，开启一个新的进程比开启一个新的线程开销大得多，而且具有独立的内存空间，使得多进程间的共享通信更加困难

线程：可以由调度程序（通常是操作系统的一部分）独立管理的最小程序指令集，**操作系统调度到CPU中执行的最小单元**。大多数情况下，线程是进程的组成部分，一个进程中可以存在多个线程，这些线程并发执行并共享进程的内存（如全局变量）等资源。而进程相对独立，不同进程具有不同的内存地址空间、代表程序运行的机器码、进程状态、操作系统资源描述符等。

在单核CPU上运行的多线程应用程序必须交织线程，交替抢占CPU的时间片。

多核CPU上，线程可以分布在多个CPU核心上，从而实现真正的并行处理。

## 线程上行下文切换

虽然多核处理器可以保证并行计算，但是实际中程序的数量以及实际运行的线程数量会比CPU核心数多得多，因此，为了平衡每个线程能够被CPU处理的时间并最大化利用CPU资源，操作系统需要在适当的时间通过定时器中断、I/O设备中断、系统调用时执行上下文切换（`Context Switch`）

当发生线程上下文切换时，需要从操作系统用户态转移到内核态，记录上一个线程的重要寄存器值（如栈寄存器值SP）、进程状态等信息。这些信息存储在操作系统**线程控制块**中，当切换到下一个要执行的线程时，需要加载重要的CPU寄存器值，并从内核态转移到操作系统用户态。如果线程在上下文切换时属于不同的进程，那么需要更新额外的状态信息及内存地址空间，同时将新的页表导入内存。

进程之间的上下文切换，最大的问题在于内存地址空间的切换导致缓存失败（例如CPU中用于缓存虚拟地址与物理地址之间映射的TLB表），所以不同进程的切换要显著慢于同一进程中线程的切换。**现代CPU使用了快速上下文切换（Rapid Context Switch）技术来解决不同进程切换带来的缓存失效问题**

## 线程与协程

在go语言中，协程被认为是轻量级的线程。和线程不同的是，操作系统内核感知不到协程的存在，协程的管理依赖go语言运行时自身提供的调度器。同时，go语言中的协程是从属于一个线程。为什么go语言需要在线程的基础上抽象出协程的概念，而不是直接操作线程？需要从调度方式、上下文切换的速度、调度策略、栈的大小这四个方面分析线程与协程的不同之处。

### 调度方式

go协程是用户态的。协程的管理依赖Go余元运行时的调度器。同时，go语言中的协程是从属于某一个线程的，协程与线程的对应关系为M:N，多对多，**go语言调度器可以将多个协程调度到一个线程中，一个协程也可能切换到多个线程中执行**

### 上下文切换速度

go协程的速度要快于线程，因为协程切换不同进过操作系统用户态与内核态的切换，并且Go语言中的协程切换只需要保留极少的状态和寄存器变量值，而线程切换会保留额外的寄存器变量值（如浮点寄存器），上下文切换的速度受到诸多因数的影响，比如：线程切换的速度大约为1~2微秒，而协程切换的速度为0.2微秒

### 调度策略

线程：线程调度大部分是抢占式的，操作系统调度器为了均衡每个线程的执行周期，会定时发出中断信号强制执行线程上下文切换。

go协程：协程在一般情况下是协作式调度的，当一个协程处理完自己的任务后，可以主动将执行权限让渡给其他协程。这意味着协程可以更好的在规定时间内完成自己的工作，而不会轻易被抢占。当一个协程运行了过长时间时，Go语言的调度器才会强制抢占其执行

### 栈的大小

线程：线程的栈大小一般是在创建   ˚          时指定的，为了避免出现栈溢出（Stack Overflow），默认的栈会相对较大（如2MB），这意味着没创建1000个线程就需要消耗2GB的虚拟内存，大大限制了线程创建的数量（64位的虚拟内存地址空间已经让这种限制变得不太严重）

go协程：协程栈默认为2kb，在实践中，经常会看到成千上万的协程存在。

线程的栈在运行时不能更改，但是Go语言中的协程在Go运行时的帮助下会**动态检查栈大小，并动态地进行扩容**。因此在实践中，可以将协程看做清量的资源。

## 并发与并行

并发和并行的区别：

并发：逻辑上具备同时处理多个任务的能力，这些任务式独立执行的单元。

并行：物理上在同一时刻执行多个并发任务

在实际的多核处理场景中，并发与并行常常是同时存在的，即多核在并行地处理多个线程，而单核中的多个线程又在上下文切换中交替执行。

由于go中的协程是依托与线程的，所以即便是处理器运行的是同一个线程，在线程内go语言调度器也会切换多个协程执行，这时协程是并发的。如果多个协程分配给了不同的线程，而这些线程同时被不同的CPU核心处理，那么这些协程就是并行处理的。

因此在多核处理场景中，协程是并发与并行同时存在的，但是协程的并发是一种更常见的现象，因为处理器的核心是有限的的，而一个程序的协程数量可以成千上万，这就需要依赖go语言吗调度器合理公平地调度

总结：通常情况下，用多进程来实现分布式和负载均衡，减轻单进程垃圾回收压力；用多线程（LWP）抢夺更多的处理器资源；用协程来提高处理器时间片和利用率